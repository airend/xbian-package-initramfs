#!/bin/sh

. /lib/lsb/init-functions
. /lib/init/mount-functions.sh
. /lib/init/vars.sh
. /lib/init/tmpfs.sh

mkdir -p /var/lock
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
mount -t proc -o nodev,noexec,nosuid proc /proc
ln -s /proc/mounts /etc/mtab 

tmpfs_size="10M"
if [ -e /etc/udev/udev.conf ]; then
        . /etc/udev/udev.conf
fi

if ! mount -t devtmpfs -o size=$tmpfs_size,mode=0755 udev /dev; then
        echo "W: devtmpfs not available, falling back to tmpfs for /dev"
        mount -t tmpfs -o size=$tmpfs_size,mode=0755 udev /dev
        [ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
        [ -e /dev/null ] || mknod /dev/null c 1 3
fi

INITIALBOOT="0"

export CONFIG_rootfstype="ext4"
export CONFIG_rootfsopts="noatime"
export CONFIG_root="/dev/mmcblk0p2"
export CONFIG_noswapfile=0
export CONFIG_init='switch_root'
export CONFIG_rootwait='0'

export CMDLINE="$(cat /proc/cmdline)"
for OPTION in ${CMDLINE}
do
	OPTIONNAME=${OPTION%%=*}
	namecheck=${OPTIONNAME##*"."}
	test ${namecheck} = ${OPTIONNAME} || continue
	VALUE=$(printf "%b" ${OPTION#*=})
	test -z ${VALUE} && VALUE='1' 
	export CONFIG_"${OPTIONNAME}"="$VALUE" 
done

mkdir /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts
mount_run mount
test -n "$CONFIG_splash" && /usr/bin/splash --infinitebar --msgtxt="cool"
mkdir -m 0755 /run/initramfs

export MODPROBE_OPTIONS="-qb"

echo > /sys/kernel/uevent_helper


UDEV_ROOT=/dev \
udevd --daemon --resolve-names=never
  if [ -e /sbin/MAKEDEV ]; then
    ln -sf /sbin/MAKEDEV /dev/MAKEDEV
  else
    ln -sf /bin/true /dev/MAKEDEV
  fi

udevadm trigger --action=add
udevadm settle || true

if [ -d /sys/bus/scsi ]; then
        modprobe -q scsi_wait_scan && modprobe -r scsi_wait_scan || true
        udevadm settle || true
fi

echo "Checking for keyboard..."
keyboard=$(/bin/ls /dev/input | grep -m1 event)
if [ "${keyboard}" != '' ]; then
	echo "? boot recovery hold left shift ?"
	sleep 2
	/usr/bin/key lshift ${keyboard}
	if [ "$?" -eq '0' ]; then 
		echo "Dropping to initramfs on request..."
 		/bin/bash
	fi
fi

if [ -n "$CONFIG_debug" ]; then
	exec >/run/initramfs/initramfs.debug 2>&1
	set -x
fi

case ${CONFIG_root} in
	/dev/nfs|nfs)
		export CONFIG_rootfstype='nfs'
		;;
	*)
		;;
esac

case ${CONFIG_rootfstype} in
	btrfs)
		## udev rule will deal with this
		;;
	/dev/nfs|nfs)
		export CONFIG_root="${CONFIG_nfsroot%%,*}"
		export CONFIG_rootfstype='nfs'
		export CONFIG_rootfsopts="${CONFIG_nfsroot#*,}"
		export CONFIG_noresizesd='1'
		if [ ${CONFIG_rootfsopts} = ${CONFIG_root} ]; then
			export CONFIG_rootfsopts=""
		fi
		chmod 777 /rootfs
		;;
	*)
		;;
esac

echo "Loading initram modules ... "
cat /etc/modules | grep -v ^# | /usr/bin/xargs -L1 modprobe
udevadm settle || true


if [ -z "$CONFIG_splash" ]; then 
	touch /run/nosplash
fi

# check if new root partition exists
X=0;
while [ ! -b "${CONFIG_root}" -a "${CONFIG_rootwait}" -eq '1'  -a "${CONFIG_rootfstype}" != "nfs" ] && [ ${X} -lt 10 ]; do
	X=$(($X+1));
	echo "$X Waiting for root..."
	sleep 1;
done;

if [ ! -b "${CONFIG_root}" -a "${CONFIG_rootfstype}" != "nfs" ]; then
	echo "Root partition ${CONFIG_root} missing"
	/bin/bash
fi

if [ -e "/sbin/sfdisk" -a -e "/sbin/fdisk" -a -e "/sbin/tune2fs" ]; then
	RESIZEERROR="0"
else
	RESIZEERROR="1"
fi

# resize root partition
if [ -z "$CONFIG_noresizesd" -a "$RESIZEERROR" -eq "0" ]; then

	#Save partition table to file
	/sbin/sfdisk -d /dev/mmcblk0 > /tmp/curpart.txt

	#Backup partition table
	cp /tmp/curpart.txt /tmp/part.txt

	#Read partition sizes
	TOTALBLOCKS=$(/sbin/fdisk -l /dev/mmcblk0 | grep total | awk '{printf "%s", $8}');
	LASTBLOCK=$TOTALBLOCKS;
	PARTSTART=$(grep Id=83 /tmp/part.txt | awk '{printf "%d", $4}');
	PARTSIZE=$(grep Id=83 /tmp/part.txt | awk '{printf "%d", $6}');
	NEWSIZE=$(($LASTBLOCK-$PARTSTART));

	if [ $PARTSIZE -lt $NEWSIZE ]; then
		#Change size of root partition
		sed -i "s/$PARTSIZE/$NEWSIZE/g" /tmp/part.txt

		#Backup current partition
		/sbin/sfdisk --no-reread -q -f /dev/mmcblk0 -O /tmp/part.bin < /tmp/part.txt >/dev/null 2>&1
		partprobe 

		#Dump new partition
		/sbin/sfdisk -d /dev/mmcblk0 > /tmp/newpart.txt

		#Check if the changes could be made to the partition table
		CHECKSIZE=$(grep Id=83 /tmp/newpart.txt | awk '{printf "%d", $6}');

		if [ $CHECKSIZE -ne $NEWSIZE ]; then
			#If partition table could not be changed
			DIFF=$(diff /tmp/curpart.txt /tmp/newpart.txt; echo $?);
			if [ ${DIFF} != "0" ]; then
				#Restoring old partition table
				/sbin/sfdisk --force -q -I /tmp/part.bin /dev/mmcblk0 & >/dev/null 2>&1
			fi
			RESIZERROR=1;
		fi
		partprobe
		sleep 1
	fi
fi

if [ -n "$CONFIG_ip" ]; then
	case "$CONFIG_ip" in 
		dhcp|auto|on)
			for f in $(basename /sys/class/net/*) ; do
				ipconfig $f

				. /run/net-$(basename $f).conf
			done
			;;
		off|no)
			;;
		*)	
			ipconfig "$CONFIG_ip"

			. /run/run-*.conf
			;;
	esac 
fi

# mount root partition
echo "Mounting root as: mount -t ${CONFIG_rootfstype} -o "$CONFIG_rw$CONFIG_ro",${CONFIG_rootfsopts} ${CONFIG_root} /rootfs"
mount -t ${CONFIG_rootfstype} -o "$CONFIG_rw$CONFIG_ro","$CONFIG_rootfsopts" "${CONFIG_root}" /rootfs
if [ "$?" -ne '0' ]; then
	echo "Mounting root partition ${CONFIG_root} failed"
	/bin/bash
fi

# check if we are in the initialboot
if [ -f /rootfs/root/initialboot ]; then
	INITIALBOOT="1"
	rm /rootfs/root/initialboot
	test -n "${CONFIG_splash}" && /rootfs/usr/bin/splash --percentage=15 --msgtxt="initial setup..."
else
	test -n "${CONFIG_splash}" && /rootfs/usr/bin/splash --percentage=15 --msgtxt="loading ..."
fi

if [ "$CONFIG_root" = "/dev/mmcblk0p2" -a  "$RESIZEERROR" -eq "0" -a -z "$CONFIG_noresizesd" ]; then
	# check if the partition needs resizing
	FDISKBLOCKSIZE=$(/sbin/sfdisk -d /dev/mmcblk0 | grep Id=83 | awk '{printf "%d", $6}');
	FDISKBLOCKCOUNT=$(/sbin/fdisk -l /dev/mmcblk0 | grep Units | sed -ne 's/\(.*= \)\([0-9]\{1,\}\)\( bytes\)/\2/p')
	TUNE2FS=$(/sbin/tune2fs -l /dev/mmcblk0p2);
	TUNEBLOCKSIZE=$(echo -e "${TUNE2FS}" | grep "Block size" | awk '{printf "%d", $3}');
	TUNEBLOCKCOUNT=$(echo -e "${TUNE2FS}" | grep "Block count" | awk '{printf "%d", $3}');
	TUNETOTALBLOCKS=$(($(($TUNEBLOCKCOUNT*$TUNEBLOCKSIZE))/1024/1024));
	FDISKTOTALBLOCKS=$(($(($FDISKBLOCKSIZE*$FDISKBLOCKCOUNT))/1024/1024));

	# resize root partition
	if [ ${TUNETOTALBLOCKS} -lt ${FDISKTOTALBLOCKS} ]; then
		if [ ${CONFIG_splash} -eq 1 ]; then
			if [ $INITIALBOOT -eq 0 ]; then
				/rootfs/usr/bin/splash --percentage=20 --msgtxt="resizing sd...";
			fi
			/rootfs/sbin/resize2fs ${CONFIG_root}
		else
echo '
8888888b.  8888888888  .d8888b.  8888888 8888888888P 8888888 888b    888  .d8888b.
888   Y88b 888        d88P  Y88b   888         d88P    888   8888b   888 d88P  Y88b
888    888 888        Y88b.        888        d88P     888   88888b  888 888    888
888   d88P 8888888     "Y888b.     888       d88P      888   888Y88b 888 888
8888888P"  888            "Y88b.   888      d88P       888   888 Y88b888 888  88888
888 T88b   888              "888   888     d88P        888   888  Y88888 888    888
888  T88b  888        Y88b  d88P   888    d88P         888   888   Y8888 Y88b  d88P
888   T88b 8888888888  "Y8888P"  8888888 d8888888888 8888888 888    Y888  "Y8888P88';
			/rootfs/sbin/resize2fs
		fi
	fi

	FDISKBLOCKSIZE=$(/sbin/sfdisk -d /dev/mmcblk0 | grep Id=83 | awk '{printf "%d", $6}');
	FDISKBLOCKCOUNT=$(/sbin/fdisk -l /dev/mmcblk0 | grep Units | sed -ne 's/\(.*= \)\([0-9]\{1,\}\)\( bytes\)/\2/p');
	TUNE2FS=$(/sbin/tune2fs -l /dev/mmcblk0p2);
	TUNEBLOCKSIZE=$(echo -e "${TUNE2FS}" | grep "Block size" | awk '{printf "%d", $3}');
	TUNEBLOCKCOUNT=$(echo -e "${TUNE2FS}" | grep "Block count" | awk '{printf "%d", $3}');
	TUNETOTALBLOCKS=$(($(($TUNEBLOCKCOUNT*$TUNEBLOCKSIZE))/1024/1024));
	FDISKTOTALBLOCKS=$(($(($FDISKBLOCKSIZE*$FDISKBLOCKCOUNT))/1024/1024));

	# check if parition was actually resized
	if [ ${TUNETOTALBLOCKS} -lt ${FDISKTOTALBLOCKS} ]; then
		RESIZEERROR="1"
	fi
fi

# create swapfile
if [ ! -f /rootfs/var/swapfile -a "$RESIZEERROR" -eq "0" -a  "$CONFIG_noswapfile" -eq "0" ]; then
	if [ $INITIALBOOT -eq "0"  ]; then
		test -n "${CONFIG_splash}" && /rootfs/usr/bin/splash --percentage=25 --msgtxt="creating swapfile..."
		dd if=/dev/zero of=/rootfs/var/swapfile bs=1024 count=128000
	else
echo '
       d8888 8888888b.  8888888b.     .d8888b.  888       888        d8888 8888888b.
      d88888 888  "Y88b 888  "Y88b   d88P  Y88b 888   o   888       d88888 888   Y88b
     d88P888 888    888 888    888   Y88b.      888  d8b  888      d88P888 888    888
    d88P 888 888    888 888    888    "Y888b.   888 d888b 888     d88P 888 888   d88P
   d88P  888 888    888 888    888       "Y88b. 888d88888b888    d88P  888 8888888P"
  d88P   888 888    888 888    888         "888 88888P Y88888   d88P   888 888
 d8888888888 888  .d88P 888  .d88P   Y88b  d88P 8888P   Y8888  d8888888888 888
d88P     888 8888888P"  8888888P"     "Y8888P"  888P     Y888 d88P     888 888';
		dd if=/dev/zero of=/rootfs/var/swapfile bs=1024 count=128000
	fi
	mkswap /rootfs/var/swapfile >/dev/null 2>&1
fi

#test -n "${CONFIG_splash}" && /rootfs/usr/bin/splash --percentagebar --percentage=40 --msgtxt="trying wifi ...";

#if [ -d "/rootfs/lib/modules/$(uname -r)" ]; then
#	# load rpi core module to initialize eth0
#	ln -s /rootfs/lib/firmware /lib/
#
#	# load additional user kernel modules
#	echo "Loading other modules ... "
#	if [ -f /rootfs/etc/modules.wifiinit ]; then
#		while read MODULE; do
#			if [ ! -z $(echo $MODULE | sed -e '/^#/d') ]; then
#				modprobe  $MODULE
#			fi
#		done < /rootfs/etc/modules.wifiinit
#	fi
#
#	if [ ! -z "${CONFIG_network_wlan0_module}" ]; then
#		modprobe ${CONFIG_network_wlan0_module}
#	fi
#	sleep 1;
#
#	if [ "${CONFIG_network_wlan0_mode}" == "dhcp" ] && [ ! -z ${CONFIG_network_wlan0_ssid} ] && [ ! -z ${CONFIG_network_wlan0_protection} ]; then
#		# remove wlan0 entry in network configuration
#                awk '/wlan0/ {flag=1} /eth0/{flag=0} !flag{print}' /rootfs/etc/network/interfaces > /rootfs/etc/network/interfaces.new
#		mv /rootfs/etc/network/interfaces.new /rootfs/etc/network/interfaces
#
#		# connect wlan0 to dhcp server
#		if [ "${CONFIG_network_wlan0_protection}" == "WPA" ] || [ "${CONFIG_network_wlan0_protection}" == "WPA2" ]; then
#	                echo -e "allow-hotplug wlan0\niface wlan0 inet dhcp\nwpa-ssid \"${CONFIG_network_wlan0_ssid}\"\nwpa-psk \"${CONFIG_network_wlan0_password}\"\n" >> /rootfs/etc/network/interfaces
#			if [ ! -d /rootfs/root/wpa_supplicant ]; then
#				mkdir /rootfs/root/wpa_supplicant;
#			fi
#			echo -e "ctrl_interface=/rootfs/root/wpa_supplicant\nupdate_config=1\nnetwork={\nssid=\"${CONFIG_network_wlan0_ssid}\"\npsk=\"${CONFIG_network_wlan0_password}\"\nkey_mgmt=WPA-PSK\nproto=RSN WPA\npairwise=CCMP TKIP\ngroup=CCMP TKIP\n}" > /etc/wpa_supplicant/wpa_supplicant.conf
#			echo -e "ctrl_interface=/root/wpa_supplicant\nupdate_config=1\nnetwork={\nssid=\"${CONFIG_network_wlan0_ssid}\"\npsk=\"${CONFIG_network_wlan0_password}\"\nkey_mgmt=WPA-PSK\nproto=RSN WPA\npairwise=CCMP TKIP\ngroup=CCMP TKIP\n}" > /rootfs/etc/wpa_supplicant/wpa_supplicant.conf
#		elif [ "${CONFIG_network_wlan0_protection}" == "WEP" ]; then
#	                echo -e "allow-hotplug wlan0\niface wlan0 inet dhcp\nwireless-ssid ${CONFIG_network_wlan0_ssid}\nwireless-key ${CONFIG_network_wlan0_password}\n" >> /rootfs/etc/network/interfaces
#		elif [ "${CONFIG_network_wlan0_protection}" == "open" ]; then
#                	echo -e "allow-hotplug wlan0\niface wlan0 inet dhcp\nwireless-ssid ${CONFIG_network_wlan0_protection}\nwireless-mode managed\n" >> /rootfs/etc/network/interfaces
#		fi
#	fi
#
#
#fi

test -n "${CONFIG_splash}" && /rootfs/usr/bin/splash --percentagebar --percentage=60 --msgtxt="loading..."

echo "Moving root"

udevadm control --exit
udev_root="/rootfs/dev"
if [ -e /etc/udev/udev.conf ]; then
  . /etc/udev/udev.conf
fi

mount -n -o move /run /rootfs/run
mount -n -o move /dev /rootfs/dev

rm -fr /dev
ln -s /rootfs/dev /dev

mount -n -o move /sys /rootfs/sys
mount -n -o move /proc /rootfs/proc
rm -fr /rootfs/etc/mtab

if [ ${CONFIG_init} = 'switch_root' ]; then
	exec switch_root /rootfs /sbin/init 
#"$@" </rootfs/dev/console >/rootfs/dev/console
else
	exec switch_root /rootfs ${CONFIG_init} 
#"$@" </rootfs/dev/console >/rootfs/dev/console
fi

echo "Failed to switch_root, dropping to a shell"
exec /bin/bash
