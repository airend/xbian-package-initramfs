#!/bin/sh

mkdir -p /var/lock
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
mount -t proc -o nodev,noexec,nosuid proc /proc
ln -s "../proc/mounts" /etc/mtab

tmpfs_size="10M"
if [ -e /etc/udev/udev.conf ]; then
        . /etc/udev/udev.conf
fi

if ! mount -t devtmpfs -o size=$tmpfs_size,mode=0755 udev /dev; then
        echo "W: devtmpfs not available, falling back to tmpfs for /dev"
        mount -t tmpfs -o size=$tmpfs_size,mode=0755 udev /dev
        [ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
        [ -e /dev/null ] || mknod /dev/null c 1 3
fi

mkdir /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts
mount -t tmpfs -o rw,nosuid,noexec,relatime,mode=755 tmpfs /run 
mkdir -m 0755 /run/initramfs

INITIALBOOT="0"

export CONFIG_rootfstype="ext4"
export CONFIG_rootfsopts="noatime"
export CONFIG_root="/dev/mmcblk0p2"
export CONFIG_noswapfile="0"
export CONFIG_init='switch_root'
export CONFIG_rootwait='0'
export CONFIG_rw='ro'
export CONFIG_noresizesd='0'

export CMDLINE="$(cat /proc/cmdline)"
for OPTION in ${CMDLINE}
do
	OPTIONNAME=${OPTION%%=*}
	namecheck=${OPTIONNAME##*"."}
	test "$namecheck" = "$OPTIONNAME" || continue
	VALUE=$(printf "%b" ${OPTION#*=})
	test "$VALUE" = "$OPTIONNAME" && VALUE='1' 
	export CONFIG_"$OPTIONNAME"="$VALUE" 
done

test -n "$CONFIG_debug" && unset CONFIG_splash
test -n "$CONFIG_rescue" && unset CONFIG_splash
test -n "$CONFIG_splash" && /usr/bin/splash --infinitebar --msgtxt="init process..."

if [ -n "$CONFIG_debug" ]; then
	exec >/run/initramfs/initramfs.debug 2>&1
	set -x
fi

export MODPROBE_OPTIONS="-qb"

echo > /sys/kernel/uevent_helper

UDEV_ROOT=/dev \
udevd --daemon --resolve-names=never
  if [ -e /sbin/MAKEDEV ]; then
    ln -sf /sbin/MAKEDEV /dev/MAKEDEV
  else
    ln -sf /bin/true /dev/MAKEDEV
  fi

udevadm trigger --action=add
udevadm settle || true

if [ -d /sys/bus/scsi ]; then
        modprobe -q scsi_wait_scan && modprobe -r scsi_wait_scan || true
        udevadm settle || true
fi

echo "Checking for keyboard..."
keyboard=$(/bin/ls /dev/input | grep -m1 event)
if [ "${keyboard}" != '' ]; then
	echo "? boot recovery hold left shift ?"
	sleep 2
	/usr/bin/key lshift ${keyboard}
	if [ "$?" -eq '0' ]; then 
		echo "Dropping to initramfs on request..."
		/bin/bash
	fi
fi

case ${CONFIG_root} in
	/dev/nfs|nfs)
		export CONFIG_rootfstype='nfs'
		;;
	*)
		;;
esac

case ${CONFIG_rootfstype} in
	btrfs)
		## udev rule will deal with this
		;;
	/dev/nfs|nfs)
		export CONFIG_root="${CONFIG_nfsroot%%,*}"
		export CONFIG_rootfstype='nfs'
		export CONFIG_rootfsopts="${CONFIG_nfsroot#*,}"
		export CONFIG_noresizesd='1'
		if [ ${CONFIG_rootfsopts} = ${CONFIG_root} ]; then
			export CONFIG_rootfsopts=""
		fi
		chmod 777 /rootfs
		;;
	*)
		;;
esac

echo "Loading initram modules ... "
cat /etc/modules | grep -v ^# | /usr/bin/xargs -L1 modprobe
udevadm settle || true

if [ -z "$CONFIG_splash" ]; then 
	touch /run/nosplash
fi

# check if new root partition exists
X='0'
while [ ! -b "$CONFIG_root" -a "$CONFIG_rootwait" -eq '1' -a "$CONFIG_rootfstype" != "nfs" -a  "$X" -lt '10' ]; do
	X=$(($X+1))
	echo "$X Waiting for root..."
	sleep 1
done

if [ ! -b "${CONFIG_root}" -a "${CONFIG_rootfstype}" != "nfs" ]; then
	echo "Root partition ${CONFIG_root} missing"
	/bin/bash
fi

if [ -e "/sbin/sfdisk" -a -e "/sbin/fdisk" -a -e "/sbin/tune2fs" -a -e "/sbin/resize2fs" ]; then
	RESIZEERROR="0"
else
	RESIZEERROR="1"
fi

if [ "$RESIZEERROR" -eq '0' -a "$CONFIG_noresizesd" -eq '0' -a "${CONFIG_rootfstype}" != "nfs" ]; then
	test -n "$CONFIG_splash" && /usr/bin/splash --infinitebar --msgtxt="sd card resize..."
	export DEV="${CONFIG_root%[0-9]}"
	export PART="2"

	pSIZE=`sfdisk -s ${DEV}[0-9] | awk -F'\n' '{ sum += $1 } END {print sum}'`

	echo ",+,,," | sfdisk -uM -N${PART} --force --no-reread -q ${DEV}

	/sbin/partprobe || true
	nSIZE=`sfdisk -s ${DEV}[0-9] | awk -F'\n' '{ sum += $1 } END {print sum}'`

	if [ $nSIZE -gt $pSIZE ]; then
		/sbin/resize2fs "$DEV$PART"
		mkdir /boot
		mount -t vfat "${DEV}1" /boot
		echo "$CMDLINE noresizesd=1" > /boot/cmdline.txt
		umount /boot
	fi
fi

if [ -n "$CONFIG_ip" ]; then
	test -n "$CONFIG_splash" && /usr/bin/splash --percentagebar --percentage=10 --msgtxt="configuring network ..."
	case "$CONFIG_ip" in 
		dhcp|auto|on)
			for f in $(basename /sys/class/net/*) ; do
				ipconfig $f

				. /run/net-$(basename $f).conf
			done
			;;
		off|no)
			;;
		*)	
			ipconfig "$CONFIG_ip"

			. /run/run-*.conf
			;;
	esac 
fi

test -n "$CONFIG_rescue" && /bin/bash

test "$CONFIG_rw" -eq '1' && export CONFIG_rw='rw'
# mount root partition
echo "Mounting root as: mount -t ${CONFIG_rootfstype} -o "$CONFIG_rw$CONFIG_ro",${CONFIG_rootfsopts} ${CONFIG_root} /rootfs"
mount -t ${CONFIG_rootfstype} -o "$CONFIG_rw","$CONFIG_rootfsopts" "${CONFIG_root}" /rootfs
if [ "$?" -ne '0' ]; then
	echo "Mounting root partition ${CONFIG_root} failed"
	/bin/bash
fi

test -n "${CONFIG_splash}" && /rootfs/usr/bin/splash --percentagebar --percentage=10 --msgtxt="loading..."

echo "Moving root"

udevadm control --exit
udev_root="/rootfs/dev"
if [ -e /etc/udev/udev.conf ]; then
  . /etc/udev/udev.conf
fi

mount -n -o move /run /rootfs/run
mount -n -o move /dev /rootfs/dev

rm -fr /dev
ln -s /rootfs/dev /dev

mount -n -o move /sys /rootfs/sys
mount -n -o move /proc /rootfs/proc

if [ ${CONFIG_init} = 'switch_root' ]; then
	exec switch_root /rootfs /sbin/init 
#"$@" </rootfs/dev/console >/rootfs/dev/console
else
	exec switch_root /rootfs ${CONFIG_init} 
#"$@" </rootfs/dev/console >/rootfs/dev/console
fi

echo "Failed to switch_root, dropping to a shell"
exec /bin/bash
