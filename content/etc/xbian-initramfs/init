#!/bin/sh

unset $(env | grep CONFIG_ | cut -f1 -d'=')

PATH=/sbin:/bin:/usr/bin:/usr/sbin:/lib/udev

echo "To dropdown to shell, hold shift on usb attached keyboard..."

. /cnvres-code.sh
. /lib/init/tmpfs.sh
. /lib/init/vars.sh
. /lib/lsb/init-functions
. /lib/init/mount-functions.sh

mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
mount -t proc -o nodev,noexec,nosuid proc /proc

if [ -e /etc/udev/udev.conf ]; then
        . /etc/udev/udev.conf
fi

mount -t devtmpfs -o size=$tmpfs_size,mode=0755 udev /dev && mkdir /dev/.udev && mkdir /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts

mount_run mount
mount_shm mount
mount_lock mount
mountpoint -q /run || { mount -t tmpfs -o rw,nosuid,noatime tmpfs /run && touch /run/.tmpfs && touch /run/zle; }
up "/run";  chmod 666 /run/uptime_start.log
mkdir -m 0755 /run/initramfs && ln -s /run/initramfs /dev/.initramfs

[ "$(grep -c -w splash /proc/cmdline)" -eq 1 ] && [ "$(grep -c -w debug /proc/cmdline)" -eq 0 ] && [ -x /usr/bin/splash ] && export CONFIG_splash=1
test -n "$CONFIG_splash" && /usr/bin/splash --infinitebar --msgtxt="init process..." 

[ "$(grep -c -w udevdrop /proc/cmdline)" -eq 1 ] && drop_shell "nomount"

echo > /sys/kernel/uevent_helper
udevd --daemon --resolve-names=never

udevadm trigger --action=add
udevadm settle --timeout=10

echo "Looking for keyboards"
X=0; while test ! -d /dev/input && test $X -le '5'; do sleep 0.5; X=$(($X+1)); done
while true; do if test -d /dev/input; then thd --daemon --triggers /trigg.shift $(find /dev/input ! -type d); break; else sleep 0.5; fi; done & pid=$!

up "dev settle"
{ test -e /etc/hostname && hostname -F /etc/hostname; } || hostname xbian

test -e /etc/mtab && rm /etc/mtab
ln -s "../proc/mounts" /etc/mtab

load_modules
up "after modprobe"
INITIALBOOT="0"
RESIZEERROR="0"

export CONFIG_rootfstype="ext4"
export CONFIG_root="/dev/mmcblk0p2"
export CONFIG_noswapfile="0"
export CONFIG_init='switch_root'
export CONFIG_rootwait='0'
export CONFIG_rw='ro'
export CONFIG_noresizesd='0'
export CONFIG_noconvertsd='0'
export CONFIG_newroot="/rootfs"

export CMDLINE="$(cat /proc/cmdline)"
for OPTION in ${CMDLINE}
do
	OPTIONNAME=${OPTION%%=*}
	echo "$OPTIONNAME" | grep -vq "\.\|-"  || continue
	VALUE=${OPTION#*=}
	test "$VALUE" = "$OPTIONNAME" && VALUE='1'
	export CONFIG_"$OPTIONNAME"="$VALUE"
done
test ! -x /usr/bin/splash && unset CONFIG_splash

up "after get cmdline"

if [ -n "$CONFIG_debug" ]; then
	unset CONFIG_rescue
	unset CONFIG_rescue_late
	unset CONFIG_cnet
	unset CONFIG_splash
	exec >>/run/initramfs/initramfs.debug 2>&1
	set -x
fi
if [ -z "$CONFIG_splash" ]; then 
	touch /run/nosplash
fi

[ -n "$CONFIG_bootmenu" ] && unset CONFIG_splash
test -n "$CONFIG_splash" && /usr/bin/splash --infinitebar --msgtxt="init process..."

up "before ipconfig"
if [ -n "$CONFIG_cnet" ]; then
	test -n "$CONFIG_splash" && /usr/bin/splash --msgtxt="configuring network..."
	case "$CONFIG_cnet" in 
		dhcp|auto|on)
			cd /sys/class/net
			for f in *; do
				test $f != "lo" && test $f != "wlan0" && ipconfig $f
			done
			cd /
			export CONFIG_cnet="dhcp"
			;;
		off|no)
			;;
		*)	
			ipconfig "$CONFIG_cnet"
			;;
	esac 
fi
ipconfig ip=127.0.0.1:255.0.0.0::::lo &>/dev/null
test -n "$(find /run/net-*.conf ! -type d 2>/dev/null)"  && update_resolv
up "after ipconfig"

case ${CONFIG_root} in
	/dev/nfs|nfs)
		export CONFIG_rootfstype='nfs'
		;;
	*)
		;;
esac
case ${CONFIG_rootfstype} in
	/dev/nfs|nfs)
		export CONFIG_root="${CONFIG_nfsroot%%,*}"
		export CONFIG_rootfstype='nfs'
		export CONFIG_rootfsopts="${CONFIG_nfsroot#*,}"
		export CONFIG_noresizesd='1'
		chmod 777 $CONFIG_newroot
		;;
	*)
		[ -z "$CONFIG_rootfsopts" ] && export CONFIG_rootfsopts="${CONFIG_root#*,}"
		export CONFIG_root="${CONFIG_root%%,*}"
		;;
esac
if [ ${CONFIG_rootfsopts} = ${CONFIG_root} ]; then
	export CONFIG_rootfsopts=""
fi

[ -n "$CONFIG_rescue_early" -o -e /run/do_drop ] && drop_shell

{ [ -z "$CONFIG_rootwait" ] || [ "$CONFIG_rootwait" -lt '10' ]; } && export CONFIG_rootwait='10'; X='0'
test -n "$CONFIG_bootmenu" && { sleep "$CONFIG_rootwait"; /bootmenu; }

if [ "$CONFIG_rootfstype" != "nfs" ]; then
while ! get_root && [ -n "$CONFIG_rootwait"  -a  "$X" -lt "$CONFIG_rootwait" ]; do
	X=$(($X+1))
	echo "$X Waiting for root..."
        sleep 1
done
test ! -b "${CONFIG_root}" && echo "Root partition ${CONFIG_root} missing" && drop_shell
fi

export FSCHECK=`blkid -s TYPE -o value -p ${CONFIG_root} `
test "$CONFIG_rootfstype" != "nfs" && { resize_part; resize_ext4; convert_btrfs; }
up "after resize, convert"

[ -n "$CONFIG_rescue" -o -e /run/do_drop ] && drop_shell

test -n "$CONFIG_partswap" && create_swap

# root needs to be rw for network settings update
export CONFIG_rw='rw'
# mount root partition
echo "Mounting root as: mount -t ${CONFIG_rootfstype} -o "$CONFIG_rw",${CONFIG_rootfsopts} ${CONFIG_root} $CONFIG_newroot"
mount -t ${CONFIG_rootfstype} -o "$CONFIG_rw","$CONFIG_rootfsopts" "${CONFIG_root}" $CONFIG_newroot
if [ "$?" -ne '0' ]; then
	echo "Mounting root partition ${CONFIG_root} failed"
	drop_shell "noumount"
fi
up "after mount"

[ -e /etc/resolv.conf ] && cp /etc/resolv.conf "${CONFIG_newroot}/etc/"

up "after net/interfaces file"

test "$CONFIG_rootfstype" != "nfs" && resize_btrfs
up "after resize_btrfs"

echo "Moving root"
move_root
test -n "${CONFIG_splash}" && chroot $CONFIG_newroot /usr/bin/splash --reopen --msgtxt="loading..." --percentagebar --percentage=15
[ -n "$CONFIG_rescue_late" -o -e /run/do_drop ] && drop_shell
kill $pid > /dev/null 2>&1; kill $(pidof thd) > /dev/null 2>&1

up "switch root"

if [ -n "$CONFIG_debug" -o -e /run/do_debug ]; then set -- --verbose $@; fi
if test -n "$CONFIG_startevent"; then set -- --startup-event=$CONFIG_startevent $@; fi
#unset debug
set +x
up "$@"
echo "Switching root"
if [ ${CONFIG_init} = 'switch_root' ]; then
	exec switch_root $CONFIG_newroot /sbin/init "$@" <$CONFIG_newroot/dev/console >$CONFIG_newroot/dev/console
else
	kill_splash
	exec run-init $CONFIG_newroot ${CONFIG_init} <$CONFIG_newroot/dev/console >$CONFIG_newroot/dev/console
fi

kill_splash
echo "Failed to switch_root, dropping to a shell"
exec /bin/bash

